# 최적화  - Optimizer

## 옵티마이저 

SQL 개발자가 SQL을 작성할 때, SQL을 어떻게 계획하게 된다. 즉, SQL 실행계획을 수립하고 SQL을 실행한다. 옵티마이저는 SQL의 실행계획을 수립하고 SQL을 실행하는 데이터베이스 관리 시스템의 소프트웨어다. 동일한 결과가 나오는 SQL도 어떻게 실행하느냐에 따라서 성능이 달라진다. 따라서 옵티마이저의 실행계획은 SQL 성능에 매우 중요한 역할을 한다. 

## 옵티마이저의 특징 

옵티마이저는 데이터 딕셔너리에 있는 오브젝트 통계, 시스템 통계 등의 정보를 사용해서 예상되는 비용을 산정한다. 옵티마이저는 여러 개의 실행 계획 중에서 최저 비용을 가지고 있는 하나를 선택해서 SQL을 실행한다. 

## 옵티마이저의 필요성 

SQL 개발자가 작성한 SQL 문을 어떻게 실행하느냐에 따라 성능이 달라진다. 

{% hint style="info" %}
예 : employees 테이블에서 찾은 행과 동일한 데이터를 departments 테이블에서 찾고 최종 결과집합을 출력할 때 
{% endhint %}

위의 예시를 실행할 때 건수가 많은 employees 테이블을 먼저 읽고 departments 테이블을 읽으면 불필요하게 비교 횟수가 증가하게 된다. SQL을 실행할 때 departments 테이블을 먼저 읽고 employees 테이블을 읽게 되면 비교 횟수를 줄일 수 있다. 

이 SQL 문은 AND 조건이기 때문에 작은 집합을 먼저 읽어도 큰 집합을 먼저 읽는 것고 동일한 결과가 나오게 된다. 

옵티마이저는 이러한 실행계획을 수립하는 것이다. 만약, 옵티마이저가 비효율적으로 실행 계획을 수립하면 SQL 개발자가 SQL을 개선해야 한다. 이때 **옵티마이저에게 실행계획을 변경하도록 요청할 수 있는데, 힌트\(HINT\)를 사용**한다.

## 옵티마이저 실행 계획 확인하기 

옵티마이저는 SQL 실행계획을 PLAN\_TABLE에 저장한다. PLAN\_TABLE을 조회해서 실행계획을 확인해보자. 

```sql
DESC PLAN_TABLE ; 
```

또한, SQL 문을 실행할 때마다 콘솔에서 실행계획을 확인할 수 있다. 



## 옵티마이저의 종류 

개발자가 SQL을 실행하면 파싱\(Parsing\)을 실행해서 SQL의 문법 검사 및 구문분석을 수행한다. 구문 분석이 완료되면 옵티마이저가 규칙 기반 혹은 비용 기반으로 실행계획을 수립한다. 옵티마이저는 기본적으로 비용 기반 옵티마이저를 사용해서 실행계획을 수립한다. 비용 기반 옵티마이저는 데이터 딕셔너리에 있는 통계 정보를 활용해서 최적의 실행계획을 수립하는 것이다. 실행계획 수립이 완료되면 최종적으로 SQL을 실행하고 실행이 완료되면 데이터를 인출\(Fetch\)한다. 

<table>
  <thead>
    <tr>
      <th style="text-align:left">&#xC635;&#xD2F0;&#xB9C8;&#xC774;&#xC800;&#xC758; &#xC885;&#xB958;</th>
      <th
      style="text-align:left">&#xC124;&#xBA85;</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">Query Transformer</td>
      <td style="text-align:left">
        <p>SQL &#xBB38;&#xC744; &#xD6A8;&#xC728;&#xC801;&#xC73C;&#xB85C; &#xC2E4;&#xD589;&#xD558;&#xAE30;
          &#xC704;&#xD574;&#xC11C; &#xC635;&#xD2F0;&#xB9C8;&#xC774;&#xC800;&#xAC00;
          &#xBCC0;&#xD658;&#xD55C;&#xB2E4;</p>
        <p>SQL&#xC774; &#xBCC0;&#xD658;&#xB418;&#xC5B4;&#xB3C4; &#xADF8; &#xACB0;&#xACFC;&#xB294;
          &#xB3D9;&#xC77C;&#xD558;&#xB2E4;</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">Estimator</td>
      <td style="text-align:left">
        <p>&#xD1B5;&#xACC4; &#xC815;&#xBCF4;&#xB97C; &#xC0AC;&#xC6A9;&#xD574;&#xC11C;
          SQL &#xC2E4;&#xD589;&#xBE44;&#xC6A9;&#xC744; &#xACC4;&#xC0B0;&#xD55C;&#xB2E4;</p>
        <p>&#xCD1D; &#xBE44;&#xC6A9;&#xC740; &#xCD5C;&#xC801;&#xC758; &#xC2E4;&#xD589;&#xACC4;&#xD68D;&#xC744;
          &#xC218;&#xB9BD;&#xD558;&#xAE30; &#xC704;&#xD574; &#xACC4;&#xC0B0;&#xD558;&#xB294;
          &#xAC83;&#xC774;&#xB2E4;</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">Plan Generator</td>
      <td style="text-align:left">SQL&#xBB38;&#xC744; &#xC2E4;&#xD589;&#xD560; &#xC2E4;&#xD589;&#xACC4;&#xD68D;&#xC744;
        &#xC218;&#xB9BD;&#xD55C;&#xB2E4;</td>
    </tr>
  </tbody>
</table>

## 옵티마이저의 엔진 

규칙 기반 옵티마이저\(Rule Base Optimizer\)는 실행 계획을 수립할 때 15개의 우선 순위를 기준으로 실행 계획을 수립한다. 최신 오라클 버전은 규칙 기반 옵티마이저보다 비용 기반 옵티마이저를 기본적으로 사용한다. 

| 우선순위    | 규칙 기반 옵티마이저의 실행계획 기준  |
| :--- | :--- |
| 1 | ROWID를 사용한 단일 행인 경 |
| 2 | 클러스터 조인에 의한 단일 행인 경우  |
| 3 | 유일하거나 기본키\(PK\)를 가진 해시 클러스터에 의한 단일 행인 경우  |
| 4 | 유일하거나 기본키\(PK\)에 의한 단일 행인 경우  |
| 5 | 클러스터 조인인 경우  |
| 6 | 해시 클러스터 조인인 경우  |
| 7 | 인덱스 클러스터 키인 경우  |
| 8 | 복합 칼럼 인덱스인 경우  |
| 9 | 단일 컬럼 인덱스인 경우  |
| 10 | 인덱스가 구성된 컬럼에서 제한된 범위를 검색하는 경우  |
| 11 | 인덱스가 구성된 컬럼에서 무제한 범위를 검색하는 경우  |
| 12 | 정렬-병합\(Sort Merge\) 조인인 경우  |
| 13 | 인덱스가 구성된 컬럼에서 MAX 혹은 MIN인 경우  |
| 14 | 인덱스가 구성된 컬럼에서 ORDER BY를 실행하는 경우  |
| 15 | 전체 테이블을 스캔\(FULL TABLE SCAN\)하는 경우  |

### ROWID 사용해서 조회해보기 

/\*+ RULE \*/ 를 사용해서 규칙 기반 옵티마이저로 실행하도록 힌트를 준다. 

```sql
SELECT /*+ RULE */ * 
FROM employees 
WHERE ROWID = '찾고자 하는 행의 ROWID' ;  
```



## 비용 기반 옵티마이저 

비용 기반 옵티마이저\(Cost Base Optimizer\)는 오브젝트 통계 및 시스템 통계를 사용해서 총 비용을 계산하고 총 비용이 적은 쪽으로 실행 계획을 수립한다. 단, 비용 기반 옵티마이저에서 통계 정보가 부적절한 경우 성능 저하가 발생할 수 있다. 총비용이란 SQL문을 실행하기 위해서 예상되는 소요시간 혹은 자원의 사용량을 의미한다. 

