# 모델링 - 정규화 / 반정규화



## 정규화

* 정규화는 함수적 종속성을 근거로한다. 함수적 종속성은 X가 변화하면 Y도 변화하는지 확인한다. 예를 들어, 회원 ID가 변화하면 이름도 변경된다. 이런 경우는 회원 ID가 기본키가 되고, 회원ID가 이름을 함수적으로 종속한다고 한다.

#### 1\) 제1정규화

* 기본키를 잡는 것
* 속성을 보고 한 개의 속성으로 유일성을 만족할 수 있는지 확인한다. 예를 들어, 제품 번호 컬럼에 1001, 1001이 두 개 있어서 중복되고, 주문번호도 두 번 이상 나와서 중복되면 유일성을 충족하지 않는다. 이 케이스는 한 개의 속성으로 유일성을 만족할 수 없다. 따라서, 제품번호+주문번호를 식별자로 해서 엔터티의 유일성을 만족하게 만든다. 제1정규화는 이렇게 유일성을 만족할 수 있는 식별자를 찾는 과정이다. \(제1정규화는 여기까지만 수행하면 됨\)

#### 2\) 제2정규화

* 제2정규화는 기본키가 두 개 이상인 경우 대상이 된다.
* 위의 케이스에서 기본키가 제품번호와 주문번호, 두 개 이므로 제2정규화 대상이 된다.
* 제2정규화는 모든 속성\(제품명, 재고 수량, 수출 여부 등\)이 식별자에 종속해야 하고 그렇지 않은 경우에는 분해한다.
* 확인 방법은 제1정규화와 마찬가지로 중복을 확인하는 것이다. 중복을 확인한 후, 속성 간 종속성을 확인해서 엔터티를 분해한다.
* 부분 함수 종속성이란 기본키가 2개 이상의 칼럼으로 이루어진 경우에만 발생함
* 기본키가 하나의 칼럼으로 이루어지면 제2정규화는 생략한다.
* 기본키에 있는 회원ID가 변경되면 이름이 변경된다. 회원ID가 이름을 함수적으로 종속하고 있는 것. 이러한 경우를 부분 함수 종속성이라고 한다. 부분 함수 종속성이 발생하면 분해를 해야 한다.
* 부분 함수 종속성을 제거하면 아래와 같다. 회원이라는 새로운 테이블이 도출되고 회원 ID가 기본키가 된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14f30fff-4f77-4901-9867-9d8c436cc33c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14f30fff-4f77-4901-9867-9d8c436cc33c/Untitled.png)

제2정규화 대상 \(부분함수 종속성 제거\)

#### 3\) 제3정규화

* 제3정규화는 이행 함수 종속성을 제거한다. 이행 함수 종속성이란, 기본키를 제외하고 칼럼 간에 종속성이 발생하는 것이다.
* 제3정규화는 제1정규화와 제2정규화를 수행한 다음에 해야 한다.
* 아래처럼 관리점이 관리점 코드에 종속되는 것을 이행 함수 종속성이라고 한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1d7577e1-85e4-4d30-b124-aa49ca44990f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1d7577e1-85e4-4d30-b124-aa49ca44990f/Untitled.png)

* 제3정규화를 수행하면 아래처럼 관리점 테이블을 도출하고 관리점 코드를 기본키로 한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2e65ec94-3167-4618-aaf4-60398f3ecad0/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2e65ec94-3167-4618-aaf4-60398f3ecad0/Untitled.png)

제3정규화\(이행 함수 종속성 제거\)

#### 4\) BCNF\(Boyce-Codd Normalization Form\)

* BCNF는 복수의 후보키가 있고, 후보키들이 복합 속성이고, 서로 중첩되는 경우다.
* 아래 예시는 기본키인 학번과 과목번호가 교수를 함수적으로 종속하고 있다. 이때, 교수가 최소성과 유일성을 만족하는 후보키이면서 교수가 과목번호를 함수적으로 종속하는 경우 분해가 일어난다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5fc7a9e5-809f-4d68-b995-f6e8207d6f6c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5fc7a9e5-809f-4d68-b995-f6e8207d6f6c/Untitled.png)

* 즉, 이런 경우 교수 테이블을 새롭게 만들고 기본키는 교수로 하고 칼럼은 과목 번호가 된다. 이러한 작업을 BCNF라고 한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5f47c045-b8e0-4f82-8460-957697064323/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5f47c045-b8e0-4f82-8460-957697064323/Untitled.png)

### 정규화와 성능

#### 1\) 정규화와 문제점

* 정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성이 높아진다. 하지만 정규화는 데이터 조회 시에 조인\(join\)을 수행하기 대문에 CPU와 메모리를 많이 사용한다. \(예를 들어, 직원 테이블과 부서 테이블로 나누어 정보를 관리하면, "사원번호, 부서코드, 부서명, 이름, 전화번호, 주소"를 조회하려면 두 테이블을 조인해야 한다\)

```text
SELECT 사원번호, 부서코드, 부서명, 이름,전화번호, 주소 
FROM 직원, 부서 
WHERE 직원.부서코드 = 부서.부서코드; 
```

* 이 명령을 프로그램으로 수행하면 중첩된 루프\(Nested Loop\)를 사용해야 한다. 즉, 이중으로 for 문을 사용해서 N개의 직원 테이블 건수와 M개의 부서 테이블 건수를 모두 비교하는 프로그램이 돌아간다. 즉, 이러한 구조는 데이터 양이 증가하면 비교해야 하는 건수도 증가한다.
* 이러한 문제를 해결하기 위해 반정규화를 하여 하나의 테이블에 저장한다면 join으로 인한 성능 저하를 해결할 수 있다.

#### 2\) 반정규화의 문제점

* 하나의 테이블에 모든 정보를 담으면 조인이 최소화되기 때문에 성능 저하 없이 조회를 빠르게 할 수 있다.
* 하지만 너무 많은 컬럼이 추가되면 한 개의 행의 크기가 데이터베이스 관리 시스템의 입출력 단위인 블록의 크기를 넘어서게 된다. 그렇게 되면 한 개의 행을 읽기 위해 여러 개의 블록을 읽어야 한다. 한 행을 읽기 위해서 여러 개의 블록을 읽게 되면 DISK IO가 증가하기 때문에 성능이 떨어지게 된다.
* 위와 같은 문제가 발생하면 결국 다시 테이블을 분해할 수밖에 없다. \(정규화\)

### 반정규화

#### 1\) 반정규화 \(De-Normalization\)

* 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
* 반정규화는 조회 속도를 향상하지만, 데이터 모델의 유연성은 낮아진다.

#### 2\) 반정규화를 수행하는 경우

* 정규화에 너무 충실해서 수행 속도가 너어무 느려지는 경우
* 다량의 범위를 자주 처리해야 하는 경우
* 특정 범위의 데이터만 자주 처리하는 경우
* 요약/집계 정보가 자주 요구되는 경우

#### 3\) 반정규화 기법 \(테이블 반정규화 / 컬럼 반정규화로 구분\)

1. 컬럼 반정규화 - 계산된 칼럼 추가

* 배치 프로그램으로 총판매액, 평균잔고, 계좌평가 등을 미리 꼐산하고, 그 결과를 특정 칼럼에 추가한다.

1. 테이블 반정규화 - 테이블 수직분할 \(칼을 수직으로\)

* 하나의 테이블을 두 개 이상의 테이블로 분할한다. 즉, 칼럼을 분할하여 새로운 테이블을 만드는 것.

1. 테이블 반정규화 - 테이블 수평분할 \(칼을 수평으로\)

* 하나의 테이블에 있는 값을 기준으로 테이블을 분할한다.

#### 참고: 파티션 기법

* 데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러 개의 데이터 파일에 분산되어서 저장된다.
* Range Partition : 데이터 값의 범위를 기준으로 파티션을 수행한다.
* List Partition : 특정 값을 지정하여 파티션을 수행한다.
* Hash Partition : 해시함수를 적용하여 파티션을 수행한다.
* Composite Partition : 범위와 해시를 복합적으로 사용하여 파티션을 수행한다.

#### 파티션 테이블의 장점

* 데이터 조회 시에 액세스 범위가 줄어들기 때문에 성능이 향상된다.
* 데이터가 분할되어 있기 때문에 IO 성능이 향상된다.
* 각 파티션을 독립적으로 백업 및 복구가 가능하다.

